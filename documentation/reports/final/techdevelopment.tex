\section{Technical Development}
\subsection{User Interface Design}
The User interface for this project is designed after looking at the user interfaces used by other music applications. In particular, the developer was inspired by Spotify, shown in figure \ref{fig:spotify}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{screen.png}
    \caption{Spotify user interface}
    \label{fig:spotify}
\end{figure}
\subsubsection{Main Display}
\begin{figure}[H]
	\centering
    \includegraphics[width=500pt]{main_diagram-crop}
    \caption{Main User interface of the project - design}
    \label{fig:main}
\end{figure}
Figure \ref{fig:main} shows the main view of the application, as mocked up before being developed and implemented. The developer took the this design, and the others which are in the appendix and produced a prototype using QtDesigner. This prototype is shown in figure \ref{fig:annotated}, updated to show details about the sheet music displayed in the PDF window.
\begin{figure}[H]
	\centering
    \includegraphics[width=500pt]{annotated_gui}
    \caption{Main User interface of the project - implementation}
    \label{fig:annotated}
\end{figure}
All of the frames of the user interface are styled using a CSS stylesheet, so that the developer could customise everything with precision. The use of CSS also enabled the developer to easily create new themes. The remaining screenshots with an explanation of how different windows link together and screenshots of the additional themes are given in the user guide which is in the appendix.

\subsection{Test Design and System Testing}
\subsubsection{Test Driven Development}
The project was developed using Test Driven Development (TDD). Test Driven Development is an Agile software development methodology which utilises the rule that a line of code should not be written unless there is a failing automated test \parencite{TDD}. This methodology has been chosen because the nature of the notation of music means that attention must be paid to how and with what symbol every element is notated, and Test Driven Development will significantly improve the quality of the software by closely integrating testing with the development process.

As such, the test plan is the same as the feature list provided in the appendix, as tests were developed at the point of introducing each new feature. Each class and file containing tests was designed to be a self contained unit testing the smallest possible details, such as an accent being added to a measure correctly, or a note's pitch being created with a particular note name or octave number.

\subsubsection{Unit Testing}
Unit tests for this project were created on an objective by objective basis using the standard Python unit tests testing suite. The developer's IDE of choice, Pycharm, has built in support for this module, with an intuitive interface for running tests in a given file and production of readable output of what happened in each tests, as shown in figure \ref{fig:testing_interface}.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{testing_interface}	
	\caption{An example of testing integration in PyCharm}
	\label{fig:testing_interface}
\end{figure}

The interface also includes the ability to create scripts which discover and run tests on folder, file, class and method level, as shown in figure \ref{fig:testscript}. The developer used this feature to create scripts which ran all of the tests for specific areas of each objective, as well as the objective itself. This enabled the developer to quickly check new features had not affected the status of previous features. 
\begin{figure}[H]
	\centering
	\includegraphics[width=400pt]{create_test_script}	
	\caption{An example of script creation in PyCharm}
	\label{fig:testscript}
\end{figure}
\subsubsection{Unit Testing the rendering system}
In the initial phase of developing the rendering system, the SAX parser was tested at base functionality level, with checks that new tags, new data and closing tags modified various lists which handler methods used to extract information. As new functions and tags were handled, more and more tests were developed for every tag, termed handler tests. These tests included combinations of tags and combinations of tag attributes, as well as testing tags in exclusion from other tags. When new features were introduced the developer would run the full set of unit tests before committing the code to source control, in order to ensure that new features did not cause regressions or changes in previously developed code.

When the object extraction algorithm portion of the rendering system was completed, the developer created unit tests for the individual symbol classes to confirm their ToLily method worked according to what was expected in the Lilypond documentation. 


Once the individual symbols were tested, the developer created tests to check the classes containing the symbols concatenated the strings of output in the correct order. As every possible value and change to each symbol had been tested at symbol class level, this portion of testing was not as extensive and only included tests to confirm ordering of notes, directions and expressions were valid where they had any effect on each other. For example, it would be unnecessary to test a note with every possible dynamic marking, but it was necessary to test a dynamic did not occur before a note.


\subsubsection{Development of Test cases}
In order to test the system more extensively, the developer created several MusicXML test cases. A full list of the test cases used is given in the appendix, as well as a sample file. In order to produce the test cases the developer used the composition software MuseScore, and systematically went through each category of symbols provided producing every possible type of symbol for that category. These were saved as individual files, titled by each category of symbol.
The developer then produced unit tests which checked the object hierarcy when the parser loaded the file. Each test and test method confirmed that the objects were in the right place within the piece, part and measure, and that each object had the appropriate values.

Once the Lilypond output section of the objective was completed, the developer reused the test cases to check their Lilypond output. Initially, the tests were primitive, only confirming that a pdf file with the same name had been created. Later, the developer produced an expected output Lilypond file and checked the output of the test against the expected output.

\subsubsection{Use of Third Party Test cases}
As there was no official test suite available for MusicXML, the Lilypond project released an unofficial collection of music xml files for testing purposes \parencite{LilypondTestcase}. Each file tests individual elements of music xml, sometimes in collaboration with other areas. In total the test suite contains 131 files and represents the most comprehensive test suite currently available openly.

The developer ran the rendering system against each test case in the suite. Initially, the developer ran them individually, visually checking the output against the images in the documentation for the test suite, and then moving test cases which passed to a separate folder from the remaining test cases. Later, an automated script was created to attempt to speed up the process, though visual checking of the output was still necessary as no Lilypond files were provided with the xml files.


Due to time constraints, the developer prioritised failures according to severity, which had three levels. The first level was failure to produce a Lilypond output due to an exception in the program. The second level was failure to produce a pdf output due to the Lilypond output being invalid. The third and final level was failure to produce a pdf output which matched the expected output. Each failure in any sense was reported using the issue tracker on Github, with an indication of the filename which failed as well as the reason for the failure. An example of such an issue report is given in figure \ref{fig:issue}.

The developer ensured that all test cases were above the first two levels of severity, and then made a decision on how important the symbol was in the context of it's usage in western music, as well as the time remaining to work on the other two primary objectives.

At the point of stopping work on the rendering system, 65$\%$ of the test cases in this suite passed and produced the correct graphical output. 
\begin{figure}[H]
	\centering
	\includegraphics[width=400pt]{issue_report}	
	\caption{An example issue report}
	\label{fig:issue}
\end{figure}

\subsubsection{Unit testing the metadata and API objectives}
Unit tests were written for the other two objectives in a similar way to the rendering system.

For the metadata scanning objective, the developer tested each element of the system in exclusion from each other. This divided the process into four classes, the folder browser, the unzipper, the data layer, and the metadata parser, as visualised in the class diagram in figure \ref{fig:metadiagram}. One main class, the music manager, handles the connections between each element. Like the rendering system, this meant that the tests for combining the elements together did not need to be so complicated as the functionality of each element had been tested rigourously.

For the online collections objective, tests were created at source API class level, then API manager level, and finally the API manager was tested when integrated with the music manager class.

\subsection{System Design}
\subsubsection{Overall Architecture}
The flow chart in figure \ref{fig:flowchart} was designed in the initial prototype phase in order to visualise how the objectives would interlink with each other.
\begin{figure}[h]
    \centering
    \includegraphics[width=400pt]{diagrams/overall_system.pdf}
    \caption{A flow diagram describing the project}
    \label{fig:flowchart}
\end{figure}

\subsubsection{Metadata Scanning system}
The flow diagram in \ref{fig:flowchart} refers to applying a metadata scanning system to the folder. This is described in more detail in the flow diagram in figure \ref{fig:meta}. 
\begin{figure}[H]
    \centering
    \includegraphics[width=250pt]{metadata_algorithm-crop}
    \caption{A flow diagram describing the meta scanning system}
    \label{fig:meta}
\end{figure}
\subsubsection{Metadata Class Structure}
The metadata scanning objective implements the popular Model View Controller design pattern, which separates the user interface (view) from the program logic (controller) and any databases or information storage (model) \parencite{mvc}.
In this instance, as shown in the class diagram in figure \ref{fig:metadiagram}, the music manager class acts as the controller, which takes input from the application interface. The music manager processes the input and turns it into requests for data, which are sent to the data layer. The data layer communicates with an SQLite file containing several tables, and sends collections of requested data back to the music manager, which updates the user interface with the new information.

The decision was taken to use this pattern in order to avoid coupling to any particular database and to ensure that the objective was properly organised according to functionality. The decision was also influenced by considerations about the future of the project, including expansions to include online data layers or improvements to the UI without affecting program logic.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{diagrams/api_and_meta_data_diagram}
    \caption{Metadata and API Class Diagram}
    \label{fig:metadiagram}
\end{figure}

\subsubsection{Modular Design}
The MVC design pattern was complemented by the implementation of the  modular design pattern, in which functions and collections of functions are separated into independent blocks or modules \parencite{modular}.

This is shown in the class diagram in figure \ref{fig:metadiagram} as the music manager also interacts with other classes such as the folder browser, which handles all functionality involving scanning the given folder for new, old, or zipped files, and the unzipper, which handles the functionality for manipulating zip files.

It is also present in the rendering system explained in detail in section 4.3.5, as each section of the object hierarchy collects its own Lilypond formatting, and then calls upon its child classes to collect theirs, finally collaborating into one complete Lilypond file. In the context of sheet music this is particularly important, as symbolic notation has many options for symbols which may or may not be present, so in program logic they must all act independently of other symbols occurring in the file.

This design was influenced by the decision to use test driven development, as this development methodology aims to test small units of program functionality in an isolated environment \parencite{TDD}.
 As such, this was easier to achieve if each independent class had one role in the system, with management classes handling the collaboration of these roles without needing to test multiple elements of functionality at once. 

This makes the code and overall architecture reusable in different situations. For example, the API manager class sends data collected online back to the Music Manager, which can then communicate with the metadata scanner to extract further information, which avoids code duplication.

\subsubsection{Rendering Architecture}
The class diagram in figure \ref{fig:classdiagram} shows an abstract structure of the sheet music rendering implementation used in this project. This implements a tree, each node of which holds an item containing the notation specific to that node. Each node object implements the ToLily method, which generates a string of Lilypond formatted output representing itself and then calls each of its child nodes in turn for their outputs, combining them into one string. 

A tree was chosen as the object structure in order to give an indication of time, and in order that specific elements could be positioned according to sequential instructions from the MusicXML parser. 

Each node in the tree inherits from the Node class. This class gives some generic methods for manipulating and returning its children, which each of the sub classes use in their own specific manipulation methods. Node is different from IndexedNode only in the sense that node contains a list of children, whilst IndexedNode stores them as a dictionary. The indexed node is used in the Staff, Voice, Measure, Part and Piece nodes because each of these classes contains items which have specified keys when they are loaded in using MusicXML, but anything below the voice node does not have an index in MusicXML.

Symbolic classes which add elements to a note or to a measure are added using the methods supplied by measure which contains the logic to decide what to do with the element. The measure handles additions, rather than the note to which the element should be assigned, as some elements must wrap the measure in Lilypond code, some must wrap a note and other more simpler elements add their code to the end of the current measure or note. The logic to decide what to do with the element is easier to achieve at measure level rather than note or direction level so that all options are available.
\begin{figure}[H]
    \centering
    \includegraphics[width=250pt]{diagrams/render-tree.png}
    \caption{Renderer Class Diagram}
    \label{fig:classdiagram}
\end{figure}




\subsubsection{Duck Typing}
The rendering system visualised by figure \ref{fig:classdiagram} implements a feature of dynamic typing known colloquially as Duck Typing. Duck Typing is a method of type inference by which the program assumes that an object is of one type according to the behaviours that it has, not the exact type or attributes it may or may not contain. %todo ref

In respect to the rendering system, duck typing is applied in the production of output, whereby each class assumes any child classes present will have the ToLily method, call the method and concatenate the results. Using this method of type inference is important to the project as this avoids assumptions about what the music will or will not contain, and instead defines that symbol as suitable for inclusion if it has the ToLily method. Using type inference means that future symbol classes which are implemented only need to provide a ToLily method and be linked into the MusicXML parser in order to be included in the output.

Duck typing can have some negative effects in system design and development. For example, if a class does not have that method this could cause the program to crash without warning. Static type checking used by other languages such as C\# and Java would avoid this problem and create a more robust program. However, the use of test driven development and the generation of test cases have counteracted this risk sufficiently to make the design decision worth taken, resulting in a fluid, experimental and rapid development environment.

\subsubsection{Designing for extensibility}
The project is designed with a particular aim of extensibility. This affects each area of the system in a different way, but in general, it means that the elements in the system are able to be modified, improved or expanded without requiring changes to the organisation of the system. 

An example of this is the API manager, which holds a dictionary of sources, with each index pointing to a class. The API manager will cycle through these sources when its methods are called, meaning that to implement a new API, the developer would simply put a new entry into this dictionary.

Each source implements the API class. To avoid causing problems with classes missing particular methods, the API class will throw a not implemented exception if the sub class does not override the method, in order to indicate to the developer working with a new API that this method is necessary.

\subsubsection{Difficulty Rating input from users}
When considering the difficulty rating objective for this project, the developer was aware of the subjective nature of sight reading and rating. To assess how this varied from instrument to instrument, the developer produced a survey which was given to a wide range of musicians, as shown in figure \ref{fig:survey_difficulty}. The results of this survey are given in the appendix.

\begin{figure}[H]
\centering
\includegraphics[width=400pt]{survey_difficulty}
\caption{An online survey on piece difficulty}
\label{fig:survey_difficulty}	
\end{figure}



\subsection{System Implementation}
\subsubsection{Development Methodology}
The project was implemented using a developer informed process. In this process, the developer would review the project's status for bugs, issues and features which had yet to be implemented and note this using the Github Issue Tracker. When the developer began working with the code, they would select an issue based on the priorities of the project, develop tests for this issue and finally, develop the production code and close the issue.


Issue tracking and reporting was used so that the developer could think and reflect on areas of the system which needed improvement, modification or implementation. The methodology worked well in the context of a year long project in which development was not continuous because it ensured that when development was paused, the developer could see instantly what needed to be done or what was being worked on before the pause to work on something else. 

This adds the benefit that in the future, when this project may be worked upon by more than one developer, new developers can see things which have yet to be implemented and choose which features are most relevant or doable by their own standards, as well as discuss or contest previous issues in the system.


\subsubsection{Challenges in the rendering system}
The renderer in this project was designed around two open formats - MusicXML and Lilypond. Whilst every effort was made to avoid coupling with either format, designing the system to work seamlessly with both formats was difficult, and many problems were encountered structuring the object format.

Initially, the project used a simpler object structure in which measures contained a list of items contained within that measure. The decision was taken to use lists of items loaded sequentially because elements belonging to each measure in MusicXML have no unique identifiers which could be used to indicate at which point they occurred within that measure, so objects had to be loaded and stored sequentially. An example is given in listing \ref{code:example}, with the visual representation given in figure \ref{fig:lilyexample}.
\lstset{
    language=xml,
    tabsize=3,
    %frame=lines,
    caption=Note followed by dynamic followed by note followed by dynamic,
    label=code:example,
    frame=shadowbox,
    rulesepcolor=\color{gray},
    xleftmargin=20pt,
    framexleftmargin=15pt,
    keywordstyle=\color{blue}\bf,
    commentstyle=\color{OliveGreen},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    showstringspaces=false,
    basicstyle=\footnotesize,
    emph={food,name,price},emphstyle={\color{magenta}}}
    \lstinputlisting{example.xml}
    
\begin{figure}[H]
\centering
\includegraphics{lilyexample-crop}
\caption{Example as represented in sheet music}
\label{fig:lilyexample}	
\end{figure}


It was then discovered that Lilypond dictates that dynamics and some other elements had to occur directly after the note to which they should be assigned \parencite{ExpressionLilypond}.  The above listing would look like figure \ref{code:lily} in Lilypond.

\begin{figure}[H]
\centering
\includegraphics{lilyexample-code}
\caption{MusicXML example written in Lilypond}
\label{code:lily}	
\end{figure}


 The system was affected because some musicXML files, such as the one given in listing \ref{code:example}, contain directions before a note has occurred within the measure, which would cause the Lilypond output to be invalid. 
 The structure had to be redesigned based on this information in order to classify notes as first class objects, for which other elements would be indexed according to which note they occurred after. Directions and expressions needed to be split into two lists, in order to ensure that expressions (like dynamics) could be put before directions, but not before the note they should be assigned to.

Later it was discovered that MusicXML allows for navigation through a measure using two specific tags called "forward" and "backup" \parencite{forward}, which in the original system would require a lot of list manipulation to position elements correctly. 

Various other feature inclusions led to the developer redesigning the system around these factors, finally reaching the tree structure described in the design section. This enabled the developer to move objects around according to the tags which next occurred.

Fundamentally, the difference in the design aims for MusicXML and Lilypond is that MusicXML dictates a sheet music file by how it appears, as in the above example, sequentially positioning the elements is how a viewer would see the overall piece. Lilypond, on the other hand, dictates a sheet music file by how it is played - after all, a dynamic without a note would not achieve the desired result as these dictate the volume of a particular element or elements of music. 

 The change in design of the system was caused by the developer analysing a limited subset of cases for both the input file format and the output format. It may have been a suggestion to extend the research period before development to accommodate this, but a research period long enough to understand the design aims of the formats in enough detail to fully design the structure from the outset would have reduced the development time by a significant amount. Redesigns and refactors were made at late stages of development, and new data structures were considered to solve the problem. The options were analysed according to their various merits in recursive sorting and searching, as well as the links which needed to be made between each symbol or element of music. The late redesign and refactor was implemented after a period of experimentation with new data structures, where a generic tree structure was assessed against a linked list. The test harness highlighted areas which the developer needed to change in order to have a working refactored system. This improved the quality of software and reduced the development time needed to find and fix problems.
 
 However, the negative side of having a test harness so extensive was that changes to production code sometimes required changes to test code, depending on the assumptions of the previous system design. Each test which failed had to be reviewed first for whether it failed because of these assumptions, or whether it was a genuine bug in the production code. Despite this negative aspect, the developer regarded the test harness as a benefit which improved the quality of the software and ensured no detail was missed. 
 
\subsubsection{Use of external technologies and libraries}
For this project, external libraries were used for the graphical user interface and for the database layer. Both were necessary to avoid development duplication and will be discussed in the sections below.

\textbf{User interface libraries} \\
There are several libraries available for creating a graphical user interface in Python, with the most popular ones summarised in table \ref{table:gui}.

\begin{table}[h]
\centering
\begin{tabu} to 1.05\textwidth {| X[c] | X[c] | X[c] | X[c] |} \hline
  {\textbf{Library}} & {\textbf{Benefits}} & {\textbf{Drawbacks}} & {\textbf{Cross platform}} \\ \hline
  Qt & Has its own designer program (QtDesigner) and some other third party designer programs & Long installation process & \checkmark \\
  & & no built in PDF viewer & \\
   &  popular amongst many languages &  & \\
   & & & \\
   &  can use CSS to style widgets & & \\\hline
  Wx 
  & Built in PDF display & Designers not as powerful as Qt + all are third party & \checkmark \\ 
  & several designers made for it &  & \\ \hline
  TKinter & Built into Python itself & No designers & \checkmark \\ 
  & & No built in PDF/PNG viewers & \\
  & & Binds to an old language which is rarely updated &  \\ \hline
  AppKit & Works well on OSX & OSX only &  $\times$ \\ \hline
  
\end{tabu}
\caption{Table of GUI libraries in Python}
\label{table:gui}
\end{table}

In Python there is only one library in popular usage (AppKit) which is locked to one platform, as shown by the table. This library was ignored due to it being locked to one platform.

In the initial phases of GUI prototyping, the developer trialled two of the suggested GUI libraries.


The first trial was TKinter, being as it is built into the Python library and did not require any further installation. TKinter is a library which provides a Python binding to TCL's user interface libraries \parencite{PythonTCL}.
 The TCL user interface library has not been updated or upgraded for today's image formats, and does not support PDF or PNGs. Any use of either of these formats required installation of other libraries, such as the Python Image Library (PIL) \parencite{PIL}.
 Furthermore, as discussed by \cite{GuiProgramming}, there are very few open, non-commercial options for graphical GUI designers for TKinter, meaning that any interfaces had to be hard coded using python code, rather than creating designed files to be imported.
 
 
 The second trial was Qt. This library took longer to install, being as PyQt, like TKinter, is only a binding to a lower level C++ library. This means that PyQt cannot be installed in the same way as Wx, using the Python Package Library pip, and for windows meant installing and compiling all sections of PyQt, Qt and SIP which links the two together from source, as no pre compiled installer was available.
 
 In addition to this development time, Qt does not provide a widget for PDF documents, which meant the developer installed a second third party library called Poppler, which is also a C++ library with Python bindings. This library was found to be far easier to use than the Python Image Library used by TKinter.
 
 Whilst this extended the time taken to produce a fully cross platform application installer, Qt provides a fully extensible QtDesigner application, which enables developers to produce their designs, including applying CSS to widgets, in a graphical user interface which outputs UI xml files. 
 
 The xml files are then loaded into Python, meaning that any changes to the files through the designer automatically affect the python binding the next time the developer runs the application.

Furthermore, as Qt is a common library to other languages and is reasonably popular, far more support was found for installing, using and extending Qt than the other libraries the developer tried to use, so the developer decided to use Qt.

Wx was not trialled because the developer felt comfortable using Qt for the reasons given above, and did not want to reduce development time further by trying a new library when Qt functioned as needed.

\textbf{Databases and Database Libraries}\\
Table \ref{table:databases} shows the options for databases the developer could have implemented in this project. These three options were selected because all of them are free and have a reasonable amount of documentation for beginners in each database.

\begin{table}[H]
\centering
\begin{tabular}{| l | l | l |} \hline
  {Database} & {Benefits} & {Drawbacks} \\ \hline
  MySQL & Open source & Installation process long \\
  & Widely used/supported & \\ \hline
  MongoDB & JSON friendly & Low developer experience with NoSQL \\ 
  & scalable & \\ \hline
  SQLite & Single file & some types not supported \\
  & Portable & not very scalable \\
  & Library built into Python & \\
  & used by a lot of other applications & \\ \hline
  
  
\end{tabular}
\caption{Table of database solutions}
\label{table:databases}
\end{table}

The first option, MySQL, was dismissed because this application is not an online solution, and as such, the developer would need to install MySQL and probably have the user install MySQL on their machine when the application was created \parencite{mysql}. MySQL is also a much larger system which is not as suited to a smaller local application.

The second option, MongoDB was dismissed because the developer did not have experience with using NoSQL, the query language used by MongoDB. Furthermore, the recommendations for MongoDB usage are when an application has large amounts of data and needs to scale \parencite{mongod}. It is not expected that there will be a large amount of data when this application is in general usage, or that scalability is a factor unless future extensions use bigger data sets.

The third and final option, SQLite, was selected because of it's portability as it only creates one file upon connection. The library for SQLite comes with Python itself and is fully documented in Python's documentation site \parencite{PythonSQLite}. The developer found the library intuitive to use which helped to reduce development time. Furthermore, SQLite is used in a lot of other applications such as iTunes, %todo ref
which means that the sheet music database produced could be more easily integrated and shared with other platforms and environments.

